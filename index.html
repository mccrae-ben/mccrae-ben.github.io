<h1 id="knock-it-over-mods-and-point-scoring-system">Knock It Over - Mods and Point Scoring System</h1>
<h2 id="-game-context-"><strong>Game Context</strong></h2>
<ul>
<li>In Knock It Over the player selects from 3 randomly generated shapes with physical properties (box, cyclinder etc…) and throws it at stacks of objects in a room. The goal of the game is to knock as many room objects over as possible to score enough points to move onto the next room.   </li>
<li>Each throwable object has modifications that alter gameplay.    <ul>
<li>ex: Throwing this object adds an additional throw   </li>
<li>ex: Having this throwable object in the room decrease gravity by X%   </li>
<li>ex: Any room object of type X knocked over with this object adds 10 points to your overall score   </li>
</ul>
</li>
<li>Each room object has base points and a base multiplier   </li>
<li><strong>Goal: Create a modification system for the Throwable Objects flexible enough to impact a lot of different aspects like:</strong>   <ul>
<li>Scoring system (add base score, increase multipliers etc..)   </li>
<li>Room physics (change the gravity of the room, make surfaces more or less absorbant etc…)   </li>
<li>Permanent or semi-permanent upgrades (number of throws, weight of objects etc…)   </li>
</ul>
</li>
</ul>
<h2 id="-issues-i-m-running-into-"><strong>Issues I&#39;m Running Into</strong></h2>
<h3 id="managing-the-instances-of-the-throwable-">Managing the instances of the Throwable:</h3>
<ul>
<li>Keeping the instanced Throwable requires logic to know if it was instanced or not, where to keep it in the Hand etc…   </li>
<li>Deleting the instance causes issues at the end of the round when I want to know if it had a modification that factors into scoring. But deleting the instance means the function   </li>
<li>Handling different mods stacks:   <ul>
<li>If it&#39;s a 1 time permanent upgrade, who owns that that upgrade has been applied and should be ignored in the future.    </li>
</ul>
</li>
<li>Proper timing for Applying mod:   <ul>
<li>Not sure the Round States that anybody can update feels very secure but not sure of a better way to handle that   </li>
<li>Who should own checking that the mod <em>should</em>  be applied. Meaning should the mod itself check that we&#39;re in the right state to process this mod   </li>
</ul>
</li>
<li>Matching variables across classes that need to be in sync:   <ul>
<li>ex: a mod might update the number of throws available to the player but the ThrowableHand doesn&#39;t know that   </li>
</ul>
</li>
</ul>
<h2 id="code-and-approach">Code and Approach</h2>
<ul>
<li><p>A GameManager autoload that tracks:   </p>
<ul>
<li>Round States (STARTED, THROWABLE_THROWN, FALLEN_OBJECTS_PROCESSED, FINAL_SCORE CALCULATED)   <ul>
<li>Any class can update the Round States via change_round_state() function   </li>
</ul>
</li>
<li>Room and object generation   </li>
<li>A score calculator   </li>
<li><p>Data relevant to the Round:   </p>
<ul>
<li>Throws left   </li>
<li>Array of Objects Thrown this round    </li>
</ul>
<p>```
extends Node</p>
</li>
</ul>
</li>
</ul>
<p>enum ROUND_STATES {NOT_SET, ROUND_STARTED, THROWABLE_PICKED, THROWABLE_THROWN, ROOM_OBJECTS_PROCESSED, ROUND_SCORE_CALCULATED, ROUND_CLEARED, ROUND_FAILED}</p>
<p>#SCORING VARIABLES
var captured_room_objects: Array[RoomObject]
var current_total_score: float = 0.0
var current_mults: float = 0.0
var total_throwable_flipped_base_score: int = 0
var total_throws: int = 3:
    set(value):
        total_throws = value
        throws_left_changed.emit(total_throws - current_throw)
var current_throw: int = 0:
    set(value):
        current_throw = value
        if current_throw &lt; total_throws:
            throws_left_changed.emit(total_throws - current_throw)
        else:
            throws_left_changed.emit(0)
            calculate_score()
var current_throwable: ThrowableObject
var throwables_played: Array[ThrowableData]
var throwables_player_go: Array[ThrowableObject]</p>
<p>#ROOM VARIABLES
var current_room: RoomGameObject
var rooms_generated: float = -1
var current_round_state: ROUND_STATES: 
    set(value):
        current_round_state = value
        round_state_changed.emit(value)</p>
<p>signal round_state_changed(current_round_state: ROUND_STATES)</p>
<h1 id="called-when-the-node-enters-the-scene-tree-for-the-first-time-">Called when the node enters the scene tree for the first time.</h1>
<p>func _ready() -&gt; void:
    current_round_state = ROUND_STATES.ROUND_STARTED
    Global.room_cleared.connect(_on_room_cleared)<br>    generate_room()</p>
<p>#SCORE CALCULATION - CALLED WHEN ALL THROWS ARE USED UP
func calculate_score():
    await get_tree().create_timer(2).timeout #wait for any final objects to be flipped
    GameManager.set_round_state(GameManager.ROUND_STATES.ROOM_OBJECTS_PROCESSED)</p>
<pre><code><span class="hljs-keyword">for</span> throwable: ThrowableObject <span class="hljs-keyword">in</span> throwables_player_go:
    throwable.apply_throwable_mod(GameManager.ROUND_STATES.ROOM_OBJECTS_PROCESSED)

<span class="hljs-keyword">for</span> room_object <span class="hljs-keyword">in</span> captured_room_objects:
    <span class="hljs-keyword">print</span>(<span class="hljs-string">"did the score do anything"</span>, room_object.score)
    <span class="hljs-comment">#CALCULATE MULTS</span>
    current_mults += room_object.room_object_data.base_mult

    <span class="hljs-keyword">var</span> previous_room_object_score: int = room_object.score
    total_throwable_flipped_base_score += (room_object.score - previous_room_object_score) <span class="hljs-comment">#This is terrible but avoids double counting since the total score already captured the base score before any mods are applied</span>
    <span class="hljs-keyword">print</span>(<span class="hljs-string">"throwable score"</span>, room_object.score)

current_total_score = total_throwable_flipped_base_score * current_mults
final_score_calculated.emit(current_total_score)
GameManager.set_round_state(GameManager.ROUND_STATES.ROUND_SCORE_CALCULATED)

<span class="hljs-keyword">if</span> current_total_score &gt;= current_room.score_needed_to_clear_room:
    current_room.cleared = <span class="hljs-literal">true</span>
    GameManager.set_round_state(GameManager.ROUND_STATES.ROUND_CLEARED)
    room_cleared.emit()
<span class="hljs-keyword">else</span>:
    GameManager.set_round_state(GameManager.ROUND_STATES.ROUND_FAILED)
</code></pre><p>func get_current_score_required():
    if GameManager.rooms_generated == -1:
        return score_required_progression[int(0)]</p>
<pre><code><span class="hljs-keyword">return</span> score_required_progression[<span class="hljs-keyword">int</span>(GameManager.rooms_generated)]
</code></pre><p>func generate_room():
    var room_data: RoomData = load(&quot;uid://coou2f25lykpb&quot;)
    var room_instance: RoomGameObject = RoomGameObject.create_instance(room_data)
    add_child(room_instance)
    rooms_generated += 1
    var updated_z_position: float = 30 * rooms_generated
    room_instance.global_position = Vector3(0,0,updated_z_position)</p>
<p>func generate_player():
    pass</p>
<p>func set_round_state(round_state: ROUND_STATES):
    current_round_state = round_state</p>
<p>func _on_room_cleared():
    generate_room()</p>
<pre><code>-<span class="ruby"> A <span class="hljs-symbol">Player:</span>   
</span>    -<span class="ruby"> All the logic <span class="hljs-keyword">for</span> throwing the Throwable   
</span>    -<span class="ruby"> A ThrowableHand component that tracks which throwables were generated, are equipped etc…</span>
</code></pre><p>extends Node3D
class_name ThrowableHand</p>
<p>var total_throwable_slots: int = 3
var current_throwable_slot_index: int = -1
var held_throwable: ThrowableObject</p>
<pre><code><span class="hljs-meta"># set(value):</span>
<span class="hljs-meta">#     held_throwable = value</span>
<span class="hljs-meta">#     if value:</span>
<span class="hljs-meta">#         GameManager.set_round_state(GameManager.ROUND_STATES.THROWABLE_PICKED)</span>
</code></pre><p>var all_throwables: Array[String]
var throwable_slots: Array[ThrowableObject]</p>
<p>func _setup():
    GameManager.round_state_changed.connect(_on_round_state_changed)
    held_throwable = null
    for throwable in all_throwables:
        var throwable_instance = ThrowableObject.create_instance(load(throwable))
        throwable_slots.append(throwable_instance)</p>
<p>func swap_held_throwable(index: int):
    if index &gt; throwable_slots.size()-1 or current_throwable_slot_index == index or throwable_slots[index] == null: #if we already have the equipped throwable selected, we&#39;ve already played that slot or the request doesn&#39;t match the size, ignore it
        return</p>
<pre><code><span class="hljs-keyword">if</span> held_throwable:
    held_throwable.queue_free()

current_throwable_slot_index = index
held_throwable = throwable_slots[index]
<span class="hljs-function"><span class="hljs-title">add_child</span><span class="hljs-params">(held_throwable)</span></span>
</code></pre><p>func go_to_next_throwable():
    swap_held_throwable(current_throwable_slot_index + 1)</p>
<p>#Clear the throwable if the round has ended
func _on_round_state_changed(current_round_state: GameManager.ROUND_STATES):
    if current_round_state == GameManager.ROUND_STATES.ROUND_SCORE_CALCULATED:
        if held_throwable:
            held_throwable.queue_free()</p>
<pre><code>- A Throwable Class   
    - Each throwable <span class="hljs-selector-tag">object</span> has <span class="hljs-selector-tag">a</span> Custom Resource that defines properties about the <span class="hljs-selector-tag">object</span> including <span class="hljs-selector-tag">a</span> custom resource <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">a</span> Mod
</code></pre><p>extends RigidBody3D
class_name ThrowableObject</p>
<p>@export var throwable_throw_force = 10
@export var followSpeed = 2
@export var followDistance = 1
@export var throwable_data: ThrowableData
@export var mesh_instance: MeshInstance3D</p>
<p>var current_level: int = 1
var mouse_position
var viewport
var object_held: bool = false
var objectPos
var targetPos
var targetRot
var startingPos
var parent
var thrown: bool = false:
    set(value):
        if value:
            if !Global.throwables_played.has(self.throwable_data):
                Global.throwables_played.append(throwable_data)
                var dupe_throwable_object: ThrowableObject = self.duplicate()
                Global.throwables_player_go.append(dupe_throwable_object)</p>
<p>func _ready() -&gt; void:
    freeze = true
    viewport = get_viewport()
    object_held = true
    parent = get_parent()
    startingPos = Global.player_instance.CAMERA_CONTROLLER.global_transform</p>
<p>static func create_instance(def: ThrowableData) -&gt; ThrowableObject:
    var instance: ThrowableObject = load(&quot;uid://b3323vwssxuio&quot;).instantiate()
    instance._setup(def)
    return instance </p>
<p>func _setup(def: ThrowableData):
    throwable_data = def
    mass = def.get_throwable_mass(float(current_level))
    var material: Material = mesh_instance.get_active_material(0)
    if material:
        var updated_material: Material = material
        updated_material.albedo_color = def.color
        mesh_instance.set_surface_override_material(0,updated_material)</p>
<pre><code><span class="hljs-function"><span class="hljs-title">apply_throwable_mod</span><span class="hljs-params">(GameManager.current_round_state)</span></span>
GameManager<span class="hljs-selector-class">.round_state_changed</span><span class="hljs-selector-class">.connect</span>(apply_throwable_mod)
</code></pre><p>func _physics_process(delta: float) -&gt; void:
    if object_held:
        hold_object()</p>
<p>func hold_object():
    targetPos = Global.player_instance.CAMERA_CONTROLLER.global_transform
    parent.global_transform = parent.global_transform.interpolate_with(targetPos.translated_local(Vector3(0,0,-3)), .3) # Held object position 
    parent.rotation.x = 0</p>
<p>func reset_throwable():
    parent.global_transform = startingPos
    self.global_transform = startingPos
    freeze = true
    object_held = true</p>
<p>func release_object():
    object_held = false
    freeze = false
    GameManager.set_round_state(GameManager.ROUND_STATES.THROWABLE_THROWN)</p>
<p>func disable_throwable():
    object_held = false</p>
<p>func apply_throwable_mod(_current_round_state: GameManager.ROUND_STATES):
    if throwable_data.throwable_mod_data.mod_script:
        throwable_data.throwable_mod_data.mod_script.apply_throwable_mod(throwable_data)</p>
<p>```</p>
<ul>
<li>A Room_Object Class:   <ul>
<li>Holds a RoomDefinition custom resource with base_score and base_mults values   </li>
<li>Tracks the state of the object   </li>
<li>Tells the GameManager that it&#39;s been flipped and should be counted   </li>
</ul>
</li>
</ul>
